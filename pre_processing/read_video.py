import cv2
import os
import shutil
import config
from pre_processing import fly_tag as ft


VIDEO_FORMAT = ['.mp4', '.avi']


class ReadVideo:
    def __init__(self):
        # Path config
        self.input_path = config.input_path  # Base Path
        self.output_path = config.output_path  # Output Path
        self.action_path = config.action_path  # If Only export action tube

        # Video config
        self.image_format = config.image_format  # Output format of Images
        self.name_length = config.name_length  # Length of video names

        self.verbose = config.verbose  # Show verbose
        self.bar_length = config.bar_length  # Length of Verbose

        self.action_names = config.action_names  # Actions
        self.counter = {action: 0 for action in self.action_names}  # Counter of actions

        self.video_list = None     # Generated Video Info
        self.by_direction = False  # If Videos are generated by input direction

    def generate_video_list(self):
        '''
        Create a list which stores information of each video. The tuple is like:
        video_info : (video_name, video_directory, output_directory, label_information)
        The output_directory is generated according to setting of the Class
            If self.by_directory is True, generated frames of each video would stored in the
            corresponding directory of the output folder
            Else, generated frames of each video would stored in the output folder.

            If self.tag_info is set to be 'local', the
        :return: List of video information
        '''
        # If output path not exists, create it
        # Else remove it contents.
        if not os.path.exists(self.output_path):
            os.makedirs(self.output_path)
        else:
            del_out = input('{0} exists, do you want remove it? Y/N'.format(self.output_path))
            if del_out in ['Y', 'y', 'yes']:
                print('Deleting {0}'.format(self.output_path))
                shutil.rmtree(self.output_path)
                os.makedirs(self.output_path)

        videos = ReadVideo.__inter_videos__(self.input_path)
        for i in range(len(videos)):
            videos[i] = self.__create_name_for_video__(videos[i])
        self.video_list = videos
        return videos

    def get_video_frame(self, video_path, output_path):
        """
        Generate frames for a given video.
        :param video_path: Path of video.
        :param output_path: Output directory.
        :return: None
        """
        counter = 0
        try:
            cap = cv2.VideoCapture(video_path)
            if not cap.isOpened():
                print('Could not open the video'.format(video_path))
                return
            video_length = self.__get_num_frames__(video_path)
            clip = video_length // self.bar_length
            print('\n')
            print('Writing Video Images From {0} to {1}'.format(video_path, output_path))
            while True:
                counter += 1
                ret, frame = cap.read()
                file_name = os.path.join(output_path, str(counter).zfill(self.name_length) + '.' + self.image_format)
                cv2.imwrite(file_name, frame)
                # Progress Bar
                if self.verbose and counter % clip == 0:
                    bar_length = counter // clip
                    print(
                        'ProgressBar: [{0}{1}]  {2}/{3}'.format('>' * bar_length, '-' * (self.bar_length - bar_length),
                                                                counter, video_length))
                if ret is False:
                    return
        except IOError:
            print('{0} is not an valid video'.format(video_path))
            return

    def generate_video_frames(self):
        if self.video_list is not None:
            assert type(self.video_list) is list
            for video in self.video_list:
                video_path = os.path.join(video[1], video[0])
                print(video_path)
                self.get_video_frame(video_path, video[2])
        else:
            print('Video list is None')
            return

    @staticmethod
    def __inter_videos__(input_path):
        """
        For a given input_path, recursively find out all videos.
        :param input_path:
        :return: Video Info, tuples as (Video_name, Video_path, Output_path, Tag_path)
        """
        [videos, directories] = ReadVideo.__get_videos__(input_path)
        for directory in directories:
            sub_videos = ReadVideo.__inter_videos__(directory)
            videos.extend(sub_videos)
        return videos

    @staticmethod
    def __get_num_frames__(video_path):
        ''' Return the number of frames of the video track of the video given '''
        CAP_PROP_FRAME_COUNT = cv2.CAP_PROP_FRAME_COUNT
        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            print('Could not open the video')
        num_frames = int(cap.get(CAP_PROP_FRAME_COUNT))
        return num_frames

    @staticmethod
    def __get_videos__(cur_path):
        """
        Get all videos and subdirectories of a given folder.
        :param cur_path
        :return: list of all videos and list of all subdirectories in the directory
        """
        files = os.listdir(cur_path)
        files_abspath = [os.path.join(cur_path, file) for file in files]
        video_path = [file for file in files_abspath if ReadVideo.__is_video__(file)]
        video_name = ['' for video in video_path]
        video_output = ['' for video in video_path]
        video_tag = ['' for video in video_path]

        directories = [os.path.join(cur_path, file) for file in files if os.path.isdir(os.path.join(cur_path, file))]

        zipped_videos = list(zip(video_name, video_path, video_output, video_tag))

        return [zipped_videos, directories]

    @staticmethod
    def __is_video__(file_path):
        """
        Check if a file is a video
        :param file_path: File path
        :return: boolean
        """
        return os.path.isfile(file_path) and os.path.splitext(file_path)[1] in VIDEO_FORMAT

    def __create_name_for_video__(self, video):
        """
        For each video, create the video name, input path, output path according to the config
        :param video: tuple: (None, video_path, None, None)
        :return: tuple: (video_name, video_path, output_path, tag_path)
        """
        video_path = video[1]

        input_path = self.input_path
        input_dirs = input_path.split(os.sep)
        output_path = self.output_path

        assert ReadVideo.__is_video__(video[1])
        [video_dir, video_name_local] = os.path.split(video_path)
        video_dirs = video_dir.split(os.sep)
        video_name = video_name_local.replace('.', '__')

        unique_dirs = [d for d in video_dirs if d not in input_dirs]
        unique_dirs.append(video_name)
        if self.by_direction:
            cur_dirs = os.sep.join(unique_dirs)
        else:
            cur_dirs = '_'.join(unique_dirs)

        video_output = os.path.join(output_path, cur_dirs)

        if not os.path.exists(video_output):
            os.makedirs(video_output)

        video_temp = (video_name_local, video_dir, video_output)
        video_tag = ft.generate_pickle(video_temp)
        video_info = (video_name_local, video_dir, video_output, video_tag)
        return video_info


if __name__ == '__main__':
    RV = ReadVideo()
    RV.generate_video_list()
